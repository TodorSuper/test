<?php
/**
 * Created by PhpStorm.
 * User: wangguangjian
 * Date: 15/11/10
 * Time: 下午19:09
 */

namespace Com\Crontab\Fc;

use System\Base;


class AccountSync extends Base
{

    private $_rule = array();

    public function __construct()
    {

        parent::__construct();
    }


    /**
     * @api {post} 同步订单信息到trade_no表
     * @apiPath Com.Crontab.Fc.AccountSync.syncAccountList
     * @apiAuthor wangguangjian <wangguangjian@liangrenwang.com>
     * @apiVersion 1.0.0
     * @apiDate 2015/11/10
     * @thinking 调取微信明细->添加第三方交易明细表(trade_no)->匹配订单中订单号和金额 if yes->修改confirm(third_status)为已对账
     *
     */
    public function syncAccountList($data)
    {
        //获取最后添加日期
        $lastTimeSql = D("FcTradeNo")->order("id desc")->limit(1)->find();
        $lastTime = $lastTimeSql["pay_time"];
        $lastTime = !$lastTime ? NOW_TIME - 172800 : $lastTime;

        //调用微信明细
        $apiPath = "Base.PayCenter.Task.BillTask.Download";
        $params = array(
            'gateway' => 'WEIXIN_WAP',//需要调用的网关
            'bill_date' => empty($data['start_time']) ? date("Y-m-d", NOW_TIME - 86400) : $data['start_time'],
            'bill_type' => '1', //查询类型 1是支付账单（pay）
        );
        $res = $this->invoke($apiPath, $params)['response'];
        if (empty($res)) $this->endInvoke(null, 8061);

        //替换时间戳
        foreach ($res as &$val) {
            $val['pay_time'] = strtotime($val['pay_time']);
            $val['trade_data'] = json_encode(array($val['pay_remote_code'] , $val['pay_time'] , $val['op_code'] , $val['amount']));
            $val['create_time'] = NOW_TIME;
        }

        //判断微信明细时间是否已经添加
        if ($res[0]['pay_time'] == $lastTime) goto reset;
        //插入微信明细
        $addId = D("FcTradeNo")->addAll($res);
        if (!$addId) $this->endInvoke(null, 8064);
        reset:
        //取出所有订单号 金额
        $opCodeList = '';
        $opArray = [];
        $amount = array();
        $opCodes = [];
        foreach ($res as $item) {
            $opCodeList .= $item['op_code'] . ",";
            $amount[$item['op_code']] = $item['amount'];
            $opArray[] = $item['op_code'];
        }
        $opCodeList = rtrim($opCodeList, ",");
        if (empty($opArray)) $this->endInvoke(null, 8073);


        //根据订单号获取所有订单数据

        $b2bFiled = 'foc.id,obo.op_code,obo.real_amount,tn.cost,foc.b2b_code';
        $advFiled = 'foc.id,ad.op_code,ad.amount,tn.cost,foc.b2b_code';
        $sql = "SELECT {$b2bFiled} FROM {$this->tablePrefix}fc_order_confirm AS foc
                JOIN {$this->tablePrefix}oc_b2b_order obo ON obo.b2b_code = foc.b2b_code
                JOIN {$this->tablePrefix}fc_trade_no tn on tn.op_code = obo.op_code
                WHERE obo.op_code in ({$opCodeList})
                UNION
                SELECT {$advFiled} FROM {$this->tablePrefix}fc_order_confirm AS foc
                JOIN {$this->tablePrefix}oc_advance ad ON ad.adv_code = foc.b2b_code
                JOIN {$this->tablePrefix}fc_trade_no tn on tn.op_code = ad.op_code
                WHERE ad.op_code in ({$opCodeList})";
        $orderInfo = D()->query($sql);
        if (!$orderInfo) $this->endInvoke(null, 8073);
        //分别取出财务点单和预付款订单号
        $id = [];
        try{
            D()->startTrans();
        foreach ($orderInfo as $val) {
            //判断当前订单是预付款还是商品订单的金额
            $real_amount =  $val['real_amount'];
            //判断当前循环内订单号是否在订单列表中 && 判断当前订单的价格是否匹配
            if (in_array($val['op_code'], $opArray) && $real_amount == $amount[$val['op_code']]) {
                $id[] = $val['id'];
            }
            $datas['cost'] = $val['cost'];
            D("FcOrderConfirm")->where("b2b_code={$val['b2b_code']}")->save($datas);
        }

        //修改跟订单号所关联的数据
        if (empty($id)) $this->endInvoke(null, 8063);
        $where['id'] = array('in', $id);
        $where['third_status'] = FC_THIRD_STATUS_NO_CHECK;

        $data['third_status'] = FC_THIRD_STATUS_CHECK;
        $update = D("FcOrderConfirm")->where($where)->data($data)->save();
            D()->commit();
        if (!$update) $this->endInvoke(null, 8053);

        } catch (\Exception $ex) {
            L($ex->getMessage());
            D()->rollback();
            L(date("Y-m-d", NOW_TIME - 86400));
        }

        //设置超时时间
        set_time_limit(0);
        return $this->res(true);
    }

    /**
     * 定时任务执行 跑入银行交易明细
     * Com.Crontab.Fc.AccountSync.syncBankList
     * @apiAuthor renyimin <renyimin@liangrenwang.com>
     * @apiVersion 1.0.0
     * @access public
     * @return void
     */
    public function syncBankList()
    {
        $timestamp = time();
        // 准备银行接口的参数
        // 银行日期参数起始为当天
        $dateFrom = date('Y-m-d',$timestamp);
        // 银行日期参结束始为当天
        $dateTo = date('Y-m-d', $timestamp);
        // 获取当前数据表中记录的最后一条银行明细的编号,作为这次查询的起始编号
        $where['create_time'] = array('BETWEEN',array(strtotime($dateFrom),strtotime($dateFrom)+86399));
        $startNumber = D('fc_bank_info')->where($where)->order('id desc')->limit(1)->getField('startNo');
        // 如果当天数据表中并没有跑入记录,则从编号1开始
        $startNo = $startNumber ? $startNumber+1 : 1;
        // 每天每次读取100条记录
        $endNo = $startNo + 100;
        //参数准备完毕, 开始调取银行接口
        $bankRes = $this->getBankInfo($dateFrom, $dateTo, $startNo, $endNo);
        // 接口调用失败
        if(($bankRes['response']['status'] != '0') || (empty($bankRes['response']['response']['list']))) {
            return $this->endInvoke($bankRes,8085);
        }
        // 接口调取成功, 则将数据跑入数据表中 (并进行状态回填)
        $this->runInsertUpdate($bankRes,$startNo);	// 此处还需要传递当前起始编号(循环递增作为每条银行明细数据的编号)
    }

    /**
     * 获取银行接口数据
     * @apiAuthor renyimin <renyimin@liangrenwang.com>
     * @access private
     * @return mixed
     */
    private function getBankInfo($dateFrom, $dateTo, $startNo, $endNo) {
        $params = array(
            'gateway' => C('BANK_PARAMS.gateway'),
            'dateFrom' => $dateFrom,
            'dateTo' => $dateTo,
            'startNo' => $startNo,
            'endNo' => $endNo,
            'typeCode' => C('BANK_PARAMS.typeCode'),
        );
        //var_dump($params);die();
        $bankRes = $this->invoke('Base.PayCenter.Info.AccountInfo.getDtl', $params);
        return $bankRes;
    }

    /**
     * 跑入并完成回填状态
     * @apiAuthor renyimin <renyimin@liangrenwang.com>
     * @apiVersion 1.0.0
     * @access private
     * @return mixed
     */
    private function runInsertUpdate($bankRes,$startNo) {
        // 对confirm表进行回填时, 需要记录需要回填的所有id
        // 对银行明细数据中有汇款码并且为银行汇款订单的明细数据进行记录(可以一次从数据表中查询出所有有汇款码并且为银行汇款的汇款订单,之后对订单金额进行比对)
        $remitCodes = array();
        foreach($bankRes['response']['response']['list'] as $key=>$val) {
            // 针对银行汇款且有汇款码的,对于汇款码进行记录
            if (($val['opAcntNo'] != C('BANK_PARAMS.weixin')) && $val['explain']) {
                $str = "'" . $val['explain'] ."'";	// 注意sql语句拼接, 无引号导致的问题
                $remitCodes[] = $str;
            }
        }
        // 开始构建sql条件
        if($remitCodes) {
            $exe = 'yes';
            $remitWhere = '(' . implode(',', $remitCodes) . ')';
        } else {
            $exe = 'no';
            $remitOrders = array();
            $remitOrders_error = array();
        }
        if($exe == 'yes') {
            // 批量查询出银行汇款且有汇款码的订单
            $fileds = "b2b.real_amount as amount,confirm.id as confirmid,extend.remit_code as remitcode";
            // 查询条件为: (未确认, 未合并, 支付方式为REMIT, 未付款) 并且 (未结算, 未对账)
            $remit_sql = "SELECT {$fileds} FROM
                       {$this->tablePrefix}fc_order_confirm  confirm
                       LEFT JOIN {$this->tablePrefix}oc_b2b_order b2b on confirm.b2b_code=b2b.b2b_code
                       LEFT JOIN {$this->tablePrefix}oc_advance adv on confirm.b2b_code=adv.adv_code
                       LEFT JOIN {$this->tablePrefix}oc_b2b_order_extend extend  on confirm.oc_code=extend.op_code
                       WHERE
                       ( confirm.status = 1 ) AND ( confirm.f_status = 1 )
                       AND ( b2b.pay_method='REMIT' OR adv.pay_method='REMIT')
                       AND ( b2b.pay_status='UNPAY' OR adv.status='UNPAY')
                       AND ( confirm.account_status='NO_ACCOUNT' )
                       AND ( confirm.balance_status = 'NO_BALANCE')
                       AND
                        ( extend.remit_code in " . $remitWhere . ")";
            $remitOrders = D()->query($remit_sql);
            // 可能存在已经点单的, 也要把错误备注体现出来
            // 批量查询出银行汇款且有汇款码的订单
            $fileds_error = "b2b.real_amount as amount,confirm.id as confirmid,extend.remit_code as remitcode";
            // 查询条件为: (未确认, 未合并, 支付方式为REMIT, 未付款) 并且 (未结算, 未对账)
            $remit_sql_error = "SELECT {$fileds_error} FROM
                       {$this->tablePrefix}fc_order_confirm  confirm
                       LEFT JOIN {$this->tablePrefix}oc_b2b_order b2b on confirm.b2b_code=b2b.b2b_code
                       LEFT JOIN {$this->tablePrefix}oc_advance adv on confirm.b2b_code=adv.adv_code
                       LEFT JOIN {$this->tablePrefix}oc_b2b_order_extend extend  on confirm.oc_code=extend.op_code
                       WHERE
                       ( confirm.status = 2 )
                       AND ( b2b.pay_method='REMIT' OR adv.pay_method='REMIT')
                       AND ( b2b.pay_status='PAY' OR adv.status='PAY')
                       AND ( extend.remit_code in " . $remitWhere . ")";
            $remitOrders_error = D()->query($remit_sql_error);
        }
        // 开始为银行明细数据的跑入做数据构建
        foreach($bankRes['response']['response']['list'] as $b_key=>$b_val) {
            // 在构建需要跑入的数据之前, 先判断该数据是否已经跑入过了,如果已经跑入过了,则不用构建该数据
            $judge = D('fc_bank_info')->where('bank_code="' . $b_val['svrId'] . '"')->select();
            if ($judge) {  // 如果已经跑入过, 则不用再次跑入 (这条写if语句只是为了阅读清楚)
                continue;
            }
            $resTag = 'NO';   // 用来判断该条明细的汇款码是否匹配到订单了
            $resTag_error = 'NO';   // 用来判断该条明细的订单是否已经被点单了
            if( !empty($b_val['explain']) ) {   // 如果有汇款码
                if($b_val['opAcntNo'] != C('BANK_PARAMS.weixin')) {  // 如果有汇款码并且不是微信（暂时考虑为银行汇款,稍后可能还会有支付宝）
                    // 先查看是否已经点单了
                    foreach ($remitOrders_error as $r_key_error => $r_val_error) {
                        if ($r_val_error['remitcode'] == $b_val['explain']) { // 如果汇款码以匹配到已经点单过的订单
                            $errorReason = '汇款码所属订单已被点单';
                            $order_num = null;
                            $account_status = FC_ACCOUNT_STATUS_NO_ACCOUNT;
                            $status = FC_STATUS_NO;
                            $order_amount = null;
                            $type = 'REMIT';
                            $resTag_error = "YES";
                            break;
                        }
                    }
                    // 如果该条明细所对应的订单确定没有被点单过
                    if ($resTag_error == "NO") {
                        foreach ($remitOrders as $r_key => $r_val) {
                            if ($r_val['remitcode'] == $b_val['explain']) { // 如果汇款码以匹配到订单
                                if ($b_val['amount'] == $r_val['amount']) { // 如果汇款码可以对上, 并且金额可以对的上, 则直接自动对账
                                    $errorReason = '';
                                    $order_num = 1;
                                    $account_status = FC_ACCOUNT_STATUS_ACCOUNT;
                                    $status = FC_STATUS_END;
                                    $type = 'REMIT';
                                    $order_amount = $r_val['amount'];
                                    $Updata[] = array(   // 回填记录id
                                        'id' => $r_val['confirmid'],
                                        'account_status' => FC_ACCOUNT_STATUS_ACCOUNT,
                                        'bank_code' => $b_val['svrId'],
                                        'balance_status' => FC_BALANCE_STATUS_YES_BALANCE,
                                    );
                                } else {   // 如果汇款码可以对上, 但是金额少于订单金额
                                    $errorReason = '有汇款码,但银行汇款金额少于订单金额';
                                    $order_num = null;
                                    $account_status = FC_ACCOUNT_STATUS_NO_ACCOUNT;
                                    $status = FC_STATUS_NO;
                                    $type = 'REMIT';
                                    $order_amount = null;
                                }
                                $resTag = "YES";    // 如果汇款码可以匹配到订单, 则进行标记, 并且退出此次汇款码对比
                                break;
                            }
                        }
                        if ($resTag == 'NO') {   // 如果汇款码最终都没有配到合适的订单
                            $errorReason = '汇款码有误';
                            $order_num = null;
                            $account_status = FC_ACCOUNT_STATUS_NO_ACCOUNT;
                            $status = FC_STATUS_NO;
                            $type = 'REMIT';
                            $order_amount = null;
                        }
                    }
                } else {
                    // 如果是微信的
                    if ($b_val['opAcntNo'] == C('BANK_PARAMS.weixin')) {
                        $type = 'WEIXIN';
                        $errorReason = '';
                    }
                    $account_status = FC_ACCOUNT_STATUS_NO_ACCOUNT;
                    $status = FC_STATUS_NO;
                    $order_num = null;
                    $order_amount = null;
                }
            } else {    // 如果无汇款码
                // 如果是微信的
                if ($b_val['opAcntNo'] == C('BANK_PARAMS.weixin')) {
                    $type = 'WEIXIN';
                    $errorReason = '';
                } else {
                    $errorReason = '无汇款码';
                    $type = 'REMIT';
                }
                $account_status = FC_ACCOUNT_STATUS_NO_ACCOUNT;
                $status = FC_STATUS_NO;
                $order_num = null;
                $order_amount = null;
            }
            $data[] = array(
                'order_amount' => $order_amount,
                'order_num' => $order_num,
                'account_status' => $account_status,
                'status' => $status,
                'pay_name' => empty($b_val['opAcntName']) ? null : $b_val['opAcntName'],
                'bank_time' => strtotime($b_val['actDate']),
                'bank_amount' => $b_val['amount'],
                'bank_code' => $b_val['svrId'],
                'remit_code' => empty($b_val['explain']) ? null : $b_val['explain'],
                //'bank_data' => '', //暂未明确
                'type' => $type,
                'create_time' => time(),
                'startNo' => $startNo,    // 记录每条数据的编号
                'errorReason' => $errorReason
            );
            $startNo++;
        }
        if($data) {
            // 批量跑入
            $tryTimes = 0;
            $this->insertTry($data,$tryTimes);
            $tryTime = 0;
            if($Updata) {
                // 批量回填
                $this->backUpdateTry($Updata, $tryTime);
            }
        } else {
            return $this->endInvoke(null, 8083); // 如果已经跑入过, 则不用再次跑入
        }
    }

    /**
     * 跑入失败时, 尝试3次回写
     * @apiAuthor renyimin <renyimin@liangrenwang.com>
     * @apiVersion 1.0.0
     * @access private
     * @return mixed
     */
    private function insertTry($addData, &$tryTimes) {
        $addRes = D('fc_bank_info')->addAll($addData);
        if(!$addRes) {
            $tryTimes++;
            if($tryTimes<=3) {
                $this->insertTry($addData, $tryTimes);
            } else {     // 尝试多次, 回写状态仍然失败
                return  $this->endInvoke(null, 8082);
            }
        } else {
            return true;
        }
    }


    /**
     * 回写失败时, 尝试3次回写
     * @apiAuthor renyimin <renyimin@liangrenwang.com>
     * @apiVersion 1.0.0
     * @access private(
     * @return mixed
     */
    private function backUpdateTry($Updata, &$tryTime) {
        foreach($Updata as $uk=>$uv) {
            $upRes = D("fcOrderConfirm")->save($uv);
        }
        if(!$upRes) {
            $tryTime++;
            if($tryTime<=3) {
                $this->backUpdateTry($Updata, $tryTime);
            } else {     // 尝试多次, 回写状态仍然失败
                return $this->endInvoke(null, 8084);
            }
        } else {
            return $this->endInvoke('ok');
        }
    }



}